"""
Run id: 52516926

Алла ошиблась при копировании из одной структуры данных в другую. Она хранила массив чисел в кольцевом буфере.
Массив был отсортирован по возрастанию, и в нём можно было найти элемент за логарифмическое время.
Алла скопировала данные из кольцевого буфера в обычный массив, но сдвинула данные исходной отсортированной
последовательности. Теперь массив не является отсортированным. Тем не менее, нужно обеспечить
возможность находить в нем элемент за O(logn).

Можно предполагать, что в массиве только уникальные элементы.
Задачу необходимо сдавать, выбрав компилятор Make! Решение отправляется файлом.
Требуемые сигнатуры функций лежат в заготовках кода на диске.

От вас требуется реализовать функцию, осуществляющую поиск в сломанном массиве.
Файлы с заготовками кода, содержащими сигнатуры функций и базовый тест для поддерживаемых языков,
находятся на Яндекс.Диске по ссылке. Обратите внимание, что считывать данные и выводить ответ не требуется.
Разрешение файла должно соответствовать языку, на котором вы пишете (.cpp, .java, .go, .js, .py).
Если вы пишете на Java, назовите файл с решением Solution.java. Для остальных языков название может
быть любым, кроме solution.ext, где ext – разрешение для вашего языка.

Формат ввода
Функция принимает массив натуральных чисел и искомое число k. Длина массива не превосходит 10000.
Элементы массива и число k не превосходят по значению 10000.
В примерах:
В первой строке записано число n –— длина массива.Во второй строке записано положительное число k –— искомый элемент.
Далее в строку через пробел записано n натуральных чисел, каждое из которых не превосходит 200000.
"""


def search_in_interval(nums, target, left, right) -> int:
    if right - left == 1:
        if nums[left] == target:
            return left
        return -1
    elif right - left == 2:
        if nums[left] == target:
            return left
        if nums[right - 1] == target:
            return right - 1
        return -1
    else:
        mid = left + (right - left) // 2

        if nums[left] <= target <= nums[mid - 1]:
            return search_in_interval(nums, target, left, mid)
        elif nums[mid] <= target <= nums[right - 1]:
            return search_in_interval(nums, target, mid, right)
        elif nums[left] > nums[mid - 1]:
            return search_in_interval(nums, target, left, mid)
        else:
            return search_in_interval(nums, target, mid, right)


def broken_search(nums, target) -> int:
    return search_in_interval(nums, target, 0, len(nums))
