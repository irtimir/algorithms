"""
L. Просеивание вниз
Ограничение времени	2 секунды
Ограничение памяти	64Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Напишите функцию, совершающую просеивание вниз в куче на максимум. Гарантируется, что порядок элементов в куче может быть нарушен только элементом, от которого запускается просеивание.
Функция принимает в качестве аргументов массив, в котором хранятся элементы кучи, и индекс элемента, от которого надо сделать просеивание вниз. Функция должна вернуть индекс, на котором элемент оказался после просеивания. Также необходимо изменить порядок элементов в переданном в функцию массиве.
Индексация в массиве, содержащем кучу, начинается с единицы. Таким образом, сыновья вершины на позиции v это 2v и2v+1. Обратите внимание, что нулевой элемент в передаваемом массиве фиктивный, вершина кучи соответствует 1-му элементу.
PIC

Формат ввода
Элементы кучи —– целые числа, лежащие в диапазоне от −10^9 до 10^9. Все элементы кучи уникальны. Передаваемый в функцию индекс лежит в диапазоне от 1 до размера передаваемого массива. В куче содержится от 1 до 105 элементов.
Замечания про отправку решений
Выберите компилятор make. Решение нужно отправлять в виде файла с расширением, которое соответствует вашему языку программирования. Если вы пишете на Java, имя файла должно быть Solution.java. Для остальных языков назовите файл my_solution.ext, заменив ext на необходимое расширение.
Мы рекомендуем воспользоваться заготовками кода для данной задачи, расположенными по ссылке.
Python
def sift_down(heap: list, idx: int) -> int
C++
#include "solution.h" // Attention!
int siftDown(std::vector<int>& heap, int idx);
Java
public class Solution {
    public static int siftDown(int[] heap, int idx) {
        // your code
    }
}
GO
package main
func siftDown(heap []int, idx int) int;
NodeJS
Пожалуйста, не используйте стрелочную нотацию при определении функции
function siftDown(hep, idx) {
    // Your code
}
"""


def sift_down(heap, idx):
    left = 2 * idx
    right = left + 1

    last_idx = len(heap) - 1

    if last_idx < left:
        return idx

    if right <= last_idx and heap[left] < heap[right]:
        index_largest = right
    else:
        index_largest = left

    if heap[idx] < heap[index_largest]:
        heap[idx], heap[index_largest] = heap[index_largest], heap[idx]
        return sift_down(heap, index_largest)
    return idx


def test():
    sample = [-1, 12, 1, 8, 3, 4, 7]
    res = sift_down(sample, 2)
    print(res)
    assert res == 5

    sample = [-1, 12, 9, 6, 2, 4, 1]
    sift_down(sample, 3)


def main():
    test()


if __name__ == '__main__':
    main()
